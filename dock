#!/bin/bash

# Docker helper script for GC React Scaffold
# Usage: dock [command] [options]

set -e

COMPOSE_FILE="docker-compose.yml"
COMPOSE_PROD_FILE="docker-compose.prod.yml"
PROJECT_NAME="gc-react"
DEV_SERVICE="app-dev"
PROD_SERVICE="app-prod"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${GREEN}✓${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}⚠${NC} $1"
}

log_error() {
    echo -e "${RED}✗${NC} $1"
}

log_step() {
    echo -e "${BLUE}→${NC} $1"
}

# Stop containers
stop_containers() {
    log_info "Stopping containers..."
    docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_FILE" down 2>/dev/null || true
    docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_PROD_FILE" down 2>/dev/null || true
}

# Check if container is running
is_running() {
    local service=$1
    local compose_file=$2
    docker-compose -p "$PROJECT_NAME" -f "$compose_file" ps "$service" | grep -q "Up" 2>/dev/null
}

# Main commands
cmd_dev() {
    local clear_cache=false
    local detached=false

    # Check for flags
    for arg in "$@"; do
        case "$arg" in
            --clear-cache)
                clear_cache=true
                ;;
            -d)
                detached=true
                ;;
        esac
    done

    if [[ "$detached" == true ]]; then
        log_step "Starting development environment in background..."
    else
        log_step "Starting development environment with live reload..."
    fi

    # Stop any running containers
    stop_containers

    # Clear cache if requested
    if [[ "$clear_cache" == true ]]; then
        log_step "Clearing Docker cache..."
        docker system prune -f
    fi

    # Build and start dev container
    if [[ "$detached" == true ]]; then
        docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_FILE" up --build -d
        log_info "Container started in detached mode. Use 'dock logs' to view logs."
    else
        docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_FILE" up --build
    fi
}

cmd_rebuild() {
    log_step "Rebuilding containers from scratch (no cache)..."

    stop_containers

    log_step "Removing old images..."
    docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_FILE" down --rmi local 2>/dev/null || true
    docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_PROD_FILE" down --rmi local 2>/dev/null || true

    log_step "Rebuilding development container..."
    docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_FILE" build --no-cache

    log_step "Rebuilding production container..."
    docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_PROD_FILE" build --no-cache

    log_info "Rebuild complete!"
}

cmd_restart() {
    log_step "Restarting development environment..."

    stop_containers

    log_step "Starting containers..."
    docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_FILE" up --build
}

cmd_stop() {
    log_step "Stopping all containers..."
    stop_containers
    log_info "All containers stopped."
}

cmd_prod() {
    local clear_cache=false

    # Check for --clear-cache flag
    if [[ "$1" == "--clear-cache" ]]; then
        clear_cache=true
    fi

    log_step "Starting production environment..."
    log_warn "Building production image (this may take a while)..."

    stop_containers

    # Clear cache if requested
    if [[ "$clear_cache" == true ]]; then
        log_step "Clearing Docker cache..."
        docker system prune -f
    fi

    log_step "Building and starting production container..."
    docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_PROD_FILE" up --build
}

cmd_clean() {
    log_step "Cleaning up Docker resources for THIS PROJECT only..."
    echo ""

    # Count resources before cleanup
    local containers_before=$(docker ps -a --filter "name=$PROJECT_NAME" -q 2>/dev/null | wc -l | tr -d ' ')
    local images_before=$(docker images --filter "reference=*$PROJECT_NAME*" -q 2>/dev/null | wc -l | tr -d ' ')
    local volumes_before=$(docker volume ls --filter "name=$PROJECT_NAME" -q 2>/dev/null | wc -l | tr -d ' ')

    # Perform cleanup with output captured
    log_step "Stopping and removing development environment..."
    docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_FILE" down --rmi local --volumes --remove-orphans 2>&1 | grep -E "(Removing|Stopping)" || true

    log_step "Stopping and removing production environment..."
    docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_PROD_FILE" down --rmi local --volumes --remove-orphans 2>&1 | grep -E "(Removing|Stopping)" || true

    # Count resources after cleanup
    local containers_after=$(docker ps -a --filter "name=$PROJECT_NAME" -q 2>/dev/null | wc -l | tr -d ' ')
    local images_after=$(docker images --filter "reference=*$PROJECT_NAME*" -q 2>/dev/null | wc -l | tr -d ' ')
    local volumes_after=$(docker volume ls --filter "name=$PROJECT_NAME" -q 2>/dev/null | wc -l | tr -d ' ')

    # Calculate what was removed
    local containers_removed=$((containers_before - containers_after))
    local images_removed=$((images_before - images_after))
    local volumes_removed=$((volumes_before - volumes_after))

    echo ""
    log_info "Project cleanup complete!"
    echo ""
    echo "Cleanup Summary:"
    echo "   Containers removed: $containers_removed"
    echo "   Images removed: $images_removed"
    echo "   Volumes removed: $volumes_removed"
    echo ""
}

cmd_prune() {
    echo ""
    echo -e "${RED}SYSTEM-WIDE Docker Prune${NC}"
    echo -e "${YELLOW}⚠  WARNING: This affects ALL Docker resources on your system, not just this project!${NC}"
    echo ""
    echo "This will remove:"
    echo "   All stopped containers (from ANY project)"
    echo "   All networks not used by at least one container"
    echo "   All unused images (from ANY project)"
    echo "   All unused volumes (from ANY project)"
    echo "   All dangling build cache"
    echo ""
    echo -e "${BLUE}To clean only this project's resources, use: dock clean${NC}"
    echo ""
    read -p "Continue with system-wide prune? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log_step "Pruning Docker system..."
        docker system prune -a --volumes -f
        log_info "System-wide prune complete! Disk space freed."
    else
        log_error "Prune cancelled."
    fi
}

cmd_status() {
    echo ""
    echo "Container Status:"
    echo ""

    echo "Development:"
    if is_running "$DEV_SERVICE" "$COMPOSE_FILE"; then
        echo -e "  Status: ${GREEN}Running${NC}"
        docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_FILE" ps "$DEV_SERVICE"
    else
        echo -e "  Status: ${RED}Stopped${NC}"
    fi

    echo ""
    echo "Production:"
    if is_running "$PROD_SERVICE" "$COMPOSE_PROD_FILE"; then
        echo -e "  Status: ${GREEN}Running${NC}"
        docker-compose -p "$PROJECT_NAME" -f "$COMPOSE_PROD_FILE" ps "$PROD_SERVICE"
    else
        echo -e "  Status: ${RED}Stopped${NC}"
    fi

    echo ""
    echo "Port Mappings:"
    docker ps --filter "name=$PROJECT_NAME" --format "table {{.Names}}\t{{.Ports}}" 2>/dev/null || echo "  No containers running"

    echo ""
    echo "Resource Usage:"
    docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}" $(docker ps -q --filter "name=$PROJECT_NAME") 2>/dev/null || echo "  No containers running"
    echo ""
}

cmd_shell() {
    local service=$DEV_SERVICE
    local compose_file=$COMPOSE_FILE

    # Check if production is running
    if is_running "$PROD_SERVICE" "$COMPOSE_PROD_FILE"; then
        service=$PROD_SERVICE
        compose_file=$COMPOSE_PROD_FILE
        log_step "Opening shell in production container..."
    elif is_running "$DEV_SERVICE" "$COMPOSE_FILE"; then
        log_step "Opening shell in development container..."
    else
        log_error "No containers are running!"
        echo "Start a container first with 'dock dev' or 'dock prod'"
        exit 1
    fi

    docker-compose -p "$PROJECT_NAME" -f "$compose_file" exec "$service" /bin/sh
}

cmd_logs() {
    local service=""
    local compose_file=$COMPOSE_FILE

    # Check for service argument
    if [[ -n "$1" ]]; then
        service="$1"
    fi

    # Determine which compose file to use
    if is_running "$PROD_SERVICE" "$COMPOSE_PROD_FILE"; then
        compose_file=$COMPOSE_PROD_FILE
        if [[ -z "$service" ]]; then
            service=$PROD_SERVICE
        fi
    elif is_running "$DEV_SERVICE" "$COMPOSE_FILE"; then
        if [[ -z "$service" ]]; then
            service=$DEV_SERVICE
        fi
    else
        log_error "No containers are running!"
        exit 1
    fi

    log_step "Following logs for $service..."
    docker-compose -p "$PROJECT_NAME" -f "$compose_file" logs -f "$service"
}

cmd_help() {
    echo "GC React Scaffold Docker Helper"
    echo ""
    echo "Usage: dock [command] [options]"
    echo ""
    echo "Common Commands:"
    echo "  dev                    Start development with live reload (foreground)"
    echo "  dev -d                 Start development in background"
    echo "  dev --clear-cache      Start development with cleared cache"
    echo "  stop                   Stop all containers"
    echo "  restart                Restart development environment"
    echo "  rebuild                Rebuild all containers from scratch (no cache)"
    echo ""
    echo "Production Commands:"
    echo "  prod [--clear-cache]   Start production container"
    echo ""
    echo "Utility Commands:"
    echo "  logs [service]         Follow container logs (defaults to active service)"
    echo "  shell                  Open shell in running container"
    echo "  status                 Show container status and resource usage"
    echo "  clean                  Clean up all Docker resources for THIS PROJECT only"
    echo "  prune                  SYSTEM-WIDE prune (affects all Docker projects)"
    echo "  help                   Show this help message"
    echo ""
    echo "Examples:"
    echo "  dock dev               # Start development server"
    echo "  dock dev -d            # Start development in background"
    echo "  dock stop              # Stop all containers"
    echo "  dock restart           # Restart development"
    echo "  dock rebuild           # Rebuild from scratch"
    echo "  dock logs              # View logs"
    echo "  dock shell             # Open shell in container"
    echo "  dock clean             # Clean up this project only"
    echo ""
}

# Main command dispatcher
case "${1:-help}" in
    dev)
        shift
        cmd_dev "$@"
        ;;
    rebuild)
        cmd_rebuild
        ;;
    restart)
        cmd_restart
        ;;
    stop)
        cmd_stop
        ;;
    prod)
        cmd_prod "$2"
        ;;
    clean)
        cmd_clean
        ;;
    prune)
        cmd_prune
        ;;
    status)
        cmd_status
        ;;
    shell)
        cmd_shell
        ;;
    logs)
        cmd_logs "$2"
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        log_error "Unknown command: $1"
        echo ""
        cmd_help
        exit 1
        ;;
esac

